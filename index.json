[{"content":"","date":"10 de noviembre de 2025","externalUrl":null,"permalink":"/","section":"Ignacio Sambrailo","summary":"","title":"Ignacio Sambrailo","type":"page"},{"content":" Introducción # A la hora de resolver problemas, a veces nos vemos tentados a buscar soluciones rápidamente, si bien esto puede ser útil para algunas situaciones cotidianas, no siempre lo es cuando se trabaja sobre el diseño de un programa, dado que podemos estar resolviendo el problema incorrecto, o hasta un problema que no existe.\nComo Testers, debemos aportar nuestro conocimiento en distintas fases del desarrollo de software, participando en etapas tempranas cuando sea posible. ¿Por qué querríamos probar algo que aún no existe?\nPorque distinto a lo que algunos puedan pensar, Testing no se trata únicamente de ejecutar pruebas, sino también de evitar que los errores sucedan, y para evitar que los errores sucedan, debemos estar presentes desde un inicio, en una etapa muy lejana a la ejecución. Cabe aclarar, que estos errores pueden ser hallados en distintos lugares, como en definiciones, diseños, o implementaciones.\nPor otro lado, algo que distingue a un principiante de alguien que tiene mayor experiencia, es su escepticismo a la hora de encarar un nuevo desarrollo. Mientras que el principiante tiende a hacer exactamente lo que le piden sin cuestionar nada, la persona experimentada tiende a querer entender el por qué. Y aquí es donde \u0026ldquo;probamos\u0026rdquo; aquello que aún no existe.\nPoner a prueba las ideas o peticiones que llegan a un proyecto es un acto de consciencia y responsabilidad que aumentan las posibilidades de que el mismo tenga futuro. No debemos dar la sensación de que cuestionamos por el sólo hecho de cuestionar, esta puede ser una tarea desafiante por momentos.\n¿Qué es \u0026ldquo;probar lo que aún no existe\u0026rdquo;? # \u0026ldquo;Probar aquello que aún no existe\u0026rdquo; es una forma bonita de decir \u0026ldquo;analizar\u0026rdquo;. La etapa de análisis en software es el pilar del resto de etapas, sin un buen análisis es más difícil que un proyecto tenga buenas bases para un posterior desarrollo y testeo.\nSin importar si te encontrás en un proyecto nuevo o avanzado, siempre aparecerá la necesidad de desarrollar/mejorar funcionalidades o resolver problemas. Una vez que una solicitud llega a nuestra puerta, es momento de probar aquello que aún no existe.\n¿Cómo lo probamos? # Si bien todos hacemos análisis en menor o mayor medida, a veces conscientemente y otras no tanto\u0026hellip; Existen formas de guiar nuestros esfuerzos en pos de una mayor efectividad.\nA la hora de explorar un nuevo desarrollo, me gusta basar mis esfuerzos en la siguiente heurística.\nLa idea es despejar la mayor cantidad de incertidumbre existente en lo que se va a desarrollar, atacando primeramente cuestiones más abarcativas y luego lo más específicas.\nImaginemos entonces un círculo gigante denominado nivel 1, que contiene a su vez a un círculo menor, nivel 2, y otro círculo aún menor, nivel 3. Podría también ser visto como las capas de una cebolla.\nNiveles de exploración Si hiciéramos el camino inverso y fuéramos de la menor incertidumbre (nivel 3) a la mayor (nivel 1), podríamos haber desperdiciado nuestro tiempo dado que las preguntas más abarcativas son las que más confianza aportan en saber que estamos yendo por el camino correcto.\nNivel 1 # En este nivel buscamos hacer preguntas que nos ayuden a entender si un desarrollo tiene sentido alguno de existir, y en caso de que lo tenga, entender su urgencia e importancia. Más precisamente, responder cuestiones como:\n¿Es la funcionalidad realmente necesaria? ¿Estamos resolviendo o atacando el problema correcto? ¿Lo estamos resolviendo de la forma adecuada? ¿Qué otros problemas pueden surgir a partir de este desarrollo? ¿Es el momento adecuado para este desarrollo? ¿Qué tan importante es que lo desarrollemos? ¿Cuánto tiempo nos podría tomar desarrollarlo/probarlo? Pensar en equipos/programas externos que se puedan ver afectados por el desarrollo. Cabe aclarar que la intención no es hacer exactamente estas preguntas directamente a alguien, dado que lejos de obtener respuestas útiles, vamos a causar un revuelo innecesario y poco productivo. Estas son las preguntas que nosotros debemos poder respondernos a nosotros mismos para estar más seguros de que lo que se va a desarrollar tenga sentido y bases sólidas.\nPor ejemplo lugar de hacer la pregunta número 1, podrías pensar acerca del contexto del proyecto y entender cosas como:\nSi la funcionalidad no está siendo cubierta por otra parte del programa actualmente. Si el problema o oportunidad que este desarrollo busca cubrir existe o es meramente una creencia infundada. Si es responsabilidad de este proyecto incorporar esta funcionalidad o no le corresponde. Si alguna de estas cuestiones te genera dudas\u0026hellip; Voilà, ya tenés algo realmente valioso para preguntar!\nCabe aclarar que para ser eficaz en este nivel es útil (no excluyente) tener un nivel de contexto, conocimiento del negocio y producto. Mientras más investigues y aprendas, más podrás aportar.\nNivel 2 # Una vez que ya nos respondimos las cuestiones del primer nivel, podemos sentirnos con más confianza y pasar a hacernos preguntas más específicas sobre el desarrollo planteado. En esta etapa buscamos:\nCuestionar cada una de las afirmaciones/requerimientos descritas en lo que se está solicitando (implícitas o explícitas). En caso de que no exista una buena descripción de lo que se busca desarrollar, redactarla. Analizar mentalmente o mediante el uso de diagramas de flujo qué implica este desarrollo en búsqueda de entender el alcance y descubrir situaciones no contempladas. Ponerse en lugar del usuario de nuestra aplicación, ya sea una persona u otro programa, ¿Cómo utilizarían esto? ¿Tienen todo lo necesario para que esto les sea de utilidad o hay algo que esté faltando? Simular mentalmente o escritamente flujos que contemplen lo desarrollado, pensar en variables que puedan afectar a nuestro programa, como lo puede ser el tiempo (horario, demora) o cuestiones intrínsecas al mismo, relacionadas a su funcionamiento o negocio. ¿Qué nuevos flujos se realizan dentro de la aplicación dada esta incorporación? Pensar en nuevos riesgos que surjan a partir de este desarrollo y cómo esto puede llegar a afectar a todos los involucrados (desarrollo, usuario, testing, etc). Evaluar si estamos asumiendo el comportamiento de partes o funciones \u0026ldquo;nuevas\u0026rdquo;, evacuando dudas y posibles problemas. ¿Qué errores serán contemplados y manejados dentro de este desarrollo? Tratar el diseño e implementación a alto nivel en búsqueda de consenso. La idea es detectar distintos errores que pudieran darse debido a información que se omite, información que no se contempla o información errónea.\nEstos puntos debieran darnos el puntapié para hacer consultas fundadas en las respuestas que obtuvimos del primer nivel, develando ambigüedades y cuestiones que habrían sido obviadas. Siendo esta una gran oportunidad para proponer mejoras o darle solución a los \u0026ldquo;casos borde\u0026rdquo; que se presenten.\nNivel 3 # En esta instancia buscamos velar por todo aquello que debiera ser cubierto una vez que la funcionalidad esté desarrollada, no necesariamente se toca el tema a ser desarrollado en sí mismo, sino también aquellas cosas que lo rodean. Puede que el área de negocio no tenga la mayor participación.\nAsegurarnos de estar comprendiendo el comportamiento esperado de la aplicación para evitar problemas de interpretación y discusiones futuras. Abogar por la testeabilidad del producto. Por ejemplo, especificaciones claras de lo que se desarrollará, límites del desarrollo, formas de facilitar la ejecución de flujos y formas de revisión del comportamiento de la aplicación. ¿Existen escenarios que no vamos a poder probar? ¿Estamos conformes con esto? ¿Qué necesitaremos para poder llevar adelante nuestras pruebas? Precondiciones, ambientes, datos, configuraciones, accesos, asistencia, etc. Pensar en un set de pruebas que haríamos contemplando los distintos flujos principales, involucrando cuestiones como: usabilidad, integración, gestión de errores, performance. Este es el momento de levantar cuestiones que pudieran interferir en nuestra misión como Testers. Puede que también salgan a la luz cuestiones que creíamos resueltas de niveles anteriores. Al final del día, esto es práctica y experiencia, es mejor enterarnos de algo en el tercer nivel que no enterarnos.\nFinalmente # Incluso explorando los tres niveles, es muy difícil contemplar todas las variables y estar igual de atento a todo, todo el tiempo. Vas a encontrarte con errores que podrían haber sido evitados en cada uno de ellos. Cada proyecto tiene sus cuestiones, al final del día, todo es un problema \u0026ldquo;de personas\u0026rdquo;, no de \u0026ldquo;máquinas\u0026rdquo;. Lo importante es que entiendas por qué sucedió, e incorporar esa cuestión en tu próxima exploración de niveles.\nCabe aclarar que hay libros enteros dedicados al análisis en el desarrollo de software, esto es simplemente una primer idea para que puedas empezar a desempeñarte conscientemente en la exploración de requerimientos. La mayoría de proyectos no requieren expertos, sino personas interesadas, muchos de nosotros estamos lejos de hacer rocket science.\n","date":"10 de noviembre de 2025","externalUrl":null,"permalink":"/posts/no_solo_ejecutes_pruebas/","section":"Publicaciones","summary":"A la hora de resolver problemas, a veces nos vemos tentados a buscar soluciones rápidamente, si bien esto puede ser útil para algunas situaciones cotidianas, no siempre lo es cuando se trabaja sobre el diseño de un programa, \u003cstrong\u003edado que podemos estar resolviendo el problema incorrecto, o hasta un problema que no existe\u003c/strong\u003e.","title":"No solo ejecutes pruebas","type":"posts"},{"content":"","date":"10 de noviembre de 2025","externalUrl":null,"permalink":"/posts/","section":"Publicaciones","summary":"","title":"Publicaciones","type":"posts"},{"content":"Leí un libro de Software Testing, más específicamente “Perfect Software And Other Illusions About Testing” de Gerald Weinberg, que en paz descanse. Antes de que te lo preguntes, no voy a tratar los temas del libro, ni es una crítica del mismo. Empecemos por algún lado, siempre quise leer algún libro de Testing de principio a fin, solo no encontraba uno que me convenza… Para ser sinceros no recuerdo cómo es que llegué a Gerald.\nGerald Weinberg fue de las primeras personas en el planeta en utilizar una computadora, de esas que ocupaban una habitación entera y cuya accesibilidad era limitada a unos pocos.\nEn una entrevista, Gerald cuenta que quiso dedicarse a la informática después de leer sobre computadoras en una revista, pero no existía ninguna carrera afín en esa época, por tanto, decidió estudiar física, su vida es muy interesante como para disminuirla a un par de frases, dejo el link a la entrevista acá.\nLuego de conocerlo, me interesé por su obra, posiblemente siguiendo el orden contrario a lo cotidiano. Cuando encontré que había escrito acerca de Testing no me lo pensé dos veces y compré el libro; de las mejores compras que hice en el año.\nPero ¿Por qué leer un libro del 2008? ¿La información no está desactualizada? ¿No quedó anticuada? ¿Vale la pena leer sobre algo a lo que ya me dedico profesionalmente?\nPrimero que nada, ni leer te hace sabio, ni por ser profesional vas a ser un buen profesional. Dicho esto, la información en libros, suele ser, muchas veces, una compilación de ideas de otros libros, así como en la música los artistas basan sus composiciones en sus preferencias musicales, los escritores suelen escribir acerca de lo que leen.\nEsto significa que leyendo un libro, lo más probable es que ya estés incorporando información pasada, es muy difícil que nadie haya escrito sobre algo antes, por tanto, las ideas que salgan de ese escrito, van a estar moldeadas por la información previa del tema.\n¿Qué sentido tendría escribir un libro si ignoramos todo aquello que ya se escribió acerca del tema que queremos abordar? Por tanto, si el autor está comprometido con su obra, es muy posible que ya haya estudiado acerca de lo que está escribiendo, es decir, que leer algo del 2024 no asegura que las ideas sean nuevas.\nAhora si, ¿Vale la pena leer sobre algo a lo que ya me dedico? Si…\nSi no hubiese leído acerca de Testing al comienzo de mi carrera, seguiría pensando que Testing es algo simple, meramente mecánico, un rol temporal, poco profundo y automatizable. Leer es desafiar nuestras ideas, es darle la oportunidad a alguien de cambiar nuestra mirada respecto a las creencias que tenemos incorporadas justa o injustamente. Incluso en el caso donde no estuviera de acuerdo con el autor, podría razonar acerca del por qué, y tener más confianza en mi postura.\nTampoco es que yo sea el mayor lector de la historia ni mucho menos, pero creo que hay valor en la inconformidad, en no creer que sabemos todo, en la “humildad intelectual”.\nSi alguien pudo cambiar mi forma de ver una profesión, de forma tan significativa, denota que sabía muy poco acerca de la misma. Mientras uno más sabe, más sabe que no sabe, por tanto, yo era víctima del efecto Dunning-Kruger y en parte, lo seguiré siendo.\nAl final del libro, Gerald da algunas recomendaciones de lectura, y dado que siento que me falta mucho por aprender para ser bueno en lo que hago, empecé a indagar sobre estos libros.\nDe a poco no solo vas conociendo más acerca de tu profesión, si no de aquellos que fueron y son referentes de la misma, así es como llegué entonces a Lee Copeland, autor del libro “A Practitioner\u0026rsquo;s Guide to Software Test Design”.\nComo es común en mi, quería conocer más acerca del autor antes de leer su obra, y es allí cuando me topé con este comentario que hizo en un video Creating a Better Testing Future | Lee Copeland | StickyMinds\nSentí que Lee había visto el futuro (ya que el video se grabó hace 10 años). La problemática que contó se podría extrapolar a muchos otros rubros sin problema.\nUna traducción sería a sus dichos sería algo como lo siguiente:\nDejame agregar algo acerca del futuro del Testing, generalmente soy pesimista, una de las cosas que hacemos en SQE es proveer evaluaciones del proceso de pruebas, las organizaciones pueden contratarnos, nosotros echamos un vistazo al proceso de pruebas que las personas están usando y damos sugerencias sobre cómo mejorarlo…\nUna de las preguntas estándar que uso en entrevistas cuando hablamos con gente en organizaciones es ¿Cuál es tu libro preferido de Software Testing? y casi sin fallar, la respuesta que escucho cada una de las veces es “Nunca leí un libro de Software Testing”, y eso me asusta.\nLos Testers quieren ser considerados profesionales, quieren que sus ideas sean respetadas y valoradas y sin embargo ni siquiera leyeron un libro sobre su propio oficio…\nCuando escuché esto entendí que los problemas en nuestra profesión no son nada actuales… Ninguna sorpresa siendo sinceros.\nEn mi opinión, cualquiera que quiera mejorar en lo que hace tiene que poder, no solo llevar a cabo su oficio, si no, poder defenderlo, explicarlo, justificarlo, por tanto, la única forma de lograr esto es formándote más allá de tu jornada laboral.\nEl hecho de que según Lee, casi todos los Testers entrevistados nunca habían leído un libro en Software Testing, me hace pensar que al menos nuestro campo puede que esté siendo dirigido por gente que tampoco leyó sobre Testing.\nY si bien esto puede que no suene importante, es como si un director de una secundaria, no estuviera recibido de una secundaria. No podemos esperar mucho de nuestra profesión si los encargados de dirigir nuestro trabajo tampoco están informados.\nEsto no solo aplicaría en Testing, sino también en cualquier otro rubro en el que se cumpla lo que Copeland menciona. Tampoco aplica a todos los “encargados”, pero se entiende el punto.\nSi no estamos de acuerdo con que nuestra profesión sea simplificada, denostada e incomprendida, no nos queda otra que ser nosotros aquellos que estudien, aprendan y mejoren para ser la referencia de los futuros Testers.\nTampoco significa que tengas que hacerlo, no todos quieren dedicarle tanto tiempo a su profesión, no a todos les interesa tanto lo que hacen y es entendible.\nPero para aquellos a los que sí les interesa, es una invitación a no dormirse en los laureles de ser profesionales. Que por cierto, solo significa ejercer un empleo.\nMejorarse a uno mismo nunca queda en uno mismo, nuestro círculo puede contagiarse por nuestra actitud. Aprender no es en vano y ser un buen profesional es un objetivo noble.\nSi te gustaría empezar leyendo algo, “Perfect Software And Other Illusions About Testing” es un buen libro, lamentablemente entiendo que no tiene traducción en español, la barrera de idioma es algo muy presente en IT, es en parte la razón por la cual escribo en español.\nUn abrazo a todos!\n","date":"12 de octubre de 2024","externalUrl":null,"permalink":"/posts/lei_un_libro_de_software_testing/","section":"Publicaciones","summary":"Leí un libro de Software Testing, más específicamente “Perfect Software And Other Illusions About Testing” de Gerald Weinberg, que en paz descanse. Antes de que te lo preguntes, no voy a tratar los temas del libro, ni es una crítica del mismo. Empecemos por algún lado, siempre quise leer algún libro de Testing de principio a fin, solo no encontraba uno que me convenza… Para ser sinceros no recuerdo cómo es que llegué a Gerald.","title":"Leí un libro de Software Testing","type":"posts"},{"content":"Estamos acostumbrados a entender ciertas actividades como “necesarias” y por tanto, restar importancia a los sentimientos que las mismas nos provocan, por ejemplo, es necesario sacar la basura en algún momento, y no es una actividad particularmente divertida o interesante, sabemos que hay que hacerlo, que consta de una secuencia de pasos incuestionables a realizar y su resultado será exitoso en cada iteración.\nEl problema se encuentra cuando trasladamos dicho concepto a nuestro trabajo, “tenemos que probar los requerimientos, caminos felices y ya, como siempre”, es innegablemente aburrido, a no ser que los requerimientos sean tan específicos que las ideas que se nos puedan ocurrir escapen lo cotidiano, pero este no suele ser el caso.\nEs normal aburrirse a veces, seamos sinceros, transcribir detalladamente un comportamiento inesperado del sistema, sabiendo que podríamos explicarlo en 2 minutos hablados puede que sea muy aburrido, pero esta no debería ser la única actividad que realizamos, por tanto, si realmente te aburris testeando puede que el asunto venga por otro lado.\nMi interés en dar un punto de vista acerca del tema radica en haber sufrido el mismo sentimiento y al mismo tiempo ver cómo este sentimiento puede ser algo común entre colegas, desanimando la profesionalidad y desincentivando el buen trabajo.\nVolvamos a las bases de nuestra profesión y cito posiblemente una de las definiciones más populares: “Quality is value to some person (who matters)” - Jerry Weinberg\u0026rsquo;s, descripción valorada por grandes figuras como Cem Kaner, Michael Bolton, entre otros.\n¿Por qué cito esta definición? Porque la base del problema del aburrimiento yace en dónde dirigimos el esfuerzo en nuestras pruebas. ¿Nos esforzamos por demostrar lo que el software debería hacer? ¿Somos máquinas de verificar criterios de aceptación? ¿Basamos la mitad de nuestros esfuerzos en “documentar”? ¿La mayor parte de nuestro trabajo pasa desapercibido?\nSi respondiste positivamente a la mayoría de estas preguntas, aburrirse es normal.\nPuede que para las personas ajenas a Testing, nuestro trabajo sea garantizar o comprobar que el producto funciona ¿Qué quieren decir con esto? ¿Que el trabajo de los desarrolladores fue pobre? ¿Que no fueron capaces de crear siquiera algo que cumpla con los criterios que se pidieron e incluso así tuvieron el descaro de decir que cumplieron con su trabajo? ¿Acaso los programadores no son responsables de su trabajo como para entregar algo que cumpla con lo que se pidió?\nSi mi trabajo se basara en meramente chequear, chequear y chequear claro que me aburriría, y también pensaría ¿Por qué no automatizamos todo esto de una buena vez y listo?\nLa gracia de nuestra labor no es “demostrar o verificar que el producto funciona”, eso lo puede hacer cualquier persona, cualquiera puede hacer que el producto funcione una vez, si realmente nos dedicaramos a eso, sería una gran pérdida de tiempo y por ende, dinero.\nIncreíblemente, esto pareciera que se le exige a la mayoría de Testers, los cuales responden comúnmente con un “funciona”, “funciona bien”. Se exige una demostración de sus chequeos a base de casos de prueba que parecen una serie de instrucciones creadas para una máquina. Se espera que los Testers cumplan con un proceso idéntico en cada escenario, incluso cuando no lo amerita.\nSi yo fuese a crear un producto ¿realmente quiero que los Testers dediquen su tiempo a eso?\nBajo mi punto de vista yo quisiera que los desarrolladores programen y entreguen X funcionalidad, y los Testers analicen, busquen bugs o riesgos durante todo el proceso. Nuestro trabajo no debería ser visto como un cuello de botella que dedica su tiempo a “re-verificar” lo mismo que ya verificó el desarrollador.\nSi el argumento es “el desarrollador pudo haberse equivocado” bien, si es tan evidente, no demorará en salir a la luz dicho error. No estoy de acuerdo en que nuestra labor sea dar el “OK” final acerca de si el producto cumple o no con lo esperado según los criterios que alguien redactó.\nLa verdad es que un programa puede tener muchos bugs e inconvenientes, pero a su vez, cumplir todos los escenarios planteados a partir de los “criterios de aceptación” al menos una vez.\nEn conclusión, no quiero que vos, Tester, te dediques a dar por cierto lo que ya conocemos del producto, quiero que te dediques a desafiar lo que creemos cierto, que te dediques a hacernos ver aquello que no conocemos del producto, y que nos importa;\nDesafiar hechos que creemos conocer. Investigar hechos que sabemos que desconocemos. Descubrir hechos que no eran conocidos y ahora pasarán a ser “conocidos, desconocidos”. Volviendo al eje central, ¿estamos aburridos de Testear, o estamos aburridos de hacer aquello que nos hicieron creer que era Testear?\nTestear no es, bajo mi punto de vista, repetir una y otra vez el mismo proceso. Testear involucra análisis, creatividad, pensamiento crítico, curiosidad, comunicación, investigación, aprendizaje, uso de herramientas, creación de reportes, estudio, modelado, lógica, percepción, interpretación, entre muchas cosas más.\n¿A qué voy con todo esto? Si hacemos siempre lo mismo, es obvio que vamos a terminar por aburrirnos. Pero, ¿cuál es la solución entonces?\nEso depende de vos, no existe una fórmula mágica o paso a paso a seguir para llevar tu Testing al otro nivel. Lo que puedo asegurarte, es que si llegaste hasta acá, significa al menos te preocupa no aburrirte en tu profesión, aunque la verdadera pregunta sería ¿Qué tan en serio te tomás tu profesión?\nTu profesión no tiene por qué ser lo que otros te dicen que es, si crees que podrías estar haciendo cosas mucho más interesantes con tu tiempo, en lugar de estar escribiendo documentación, sacando capturas de pantalla y siguiendo un libreto, hacelas, toma responsabilidad sobre tu trabajo, tu trabajo es tuyo, si tuvieras que juzgarlo ¿Qué tanto podrías defenderlo? No deberías defenderlo diciendo “es lo que otros dicen que hay que hacer”.\nEn conclusión, las veces que sentí que mi trabajo se había tornado en algo aburrido, fue principalmente por la falta de propósito que encontraba en los procesos que se practicaban en el proyecto en cuanto a Testing se refiere.\nPara salir de ese pozo comencé a hacerme muchas preguntas, y creo que el eje central radica en ser responsable en cuanto a tu trabajo;\n¿Cuáles procesos valen la pena realizar? ¿Cuáles de mis actividades son más beneficiosas para el equipo? ¿Cómo explico la importancia de hacer y dejar de hacer ciertas tareas? ¿A qué vale la pena dedicarle mi tiempo? ¿Por qué pruebo lo que pruebo y por qué lo pruebo de X manera? ¿Qué espera el cliente de mi, qué tanto entiende acerca de Testing? ¿Dónde encuentra el cliente valor real en su producto? ¿Qué espera el cliente del proceso de pruebas? ¿Cómo puedo representar mi trabajo de forma gráfica? ¿Cómo puedo hacer visible mis actividades? ¿Estoy conforme con mi forma de trabajo y los resultados que obtengo? ¿Estoy conforme con mis conocimientos en distintos tópicos relacionados a Testing? ¿Puedo defender mi trabajo ante otras personas, incluso ante un jurado? Si una persona a la que respeto, viera mi labor ¿Le gustaría lo que ve? ¿Cuáles son los puntos débiles de mi trabajo, dónde puedo mejorar? ¿El equipo se siente mejor sabiendo que estoy con ellos? ¿Me siento orgulloso de lo que hago como Tester? ¿Me adapto a las distintas situaciones donde se me requiere? ¿Se suele buscar mi participación en las distintas etapas del desarrollo? Algunas de estas preguntas son muy profundas o complejas de responder, otras un poco más directas y al grano, creo que si te hiciste algunas de ellas alguna vez, al menos te tomas en serio tu trabajo.\nCreo que la superación del aburrimiento viene por ese lado, abandonar aquellas ideas o tareas que podemos demostrar que no aportan valor a nuestro trabajo, y dedicarnos plenamente a aquellas que sabemos que si valen la pena, aquellas que no constan de un circuito repetitivo que no nos lleva al resultado esperado.\nLo difícil es encontrar nuestra forma de trabajo, una forma que nos convenza tanto a nosotros, como a aquellos que dependen de nuestra labor como Testers. Creo que la superación de ese aburrimiento es el comienzo de un camino hacia una profesión que nos llene, derivando entonces nuestros esfuerzos hacia aprender, entender, apreciar, valorar, defender y practicar nuestro trabajo, ser realmente responsables de lo que hacemos.\nNo hay nada de malo en aburrirse, pero cuando se transforma en la norma, algo anda mal, embarquémonos en la búsqueda hacia un mejor Testing y menor aburrimiento.\n","date":"7 de agosto de 2024","externalUrl":null,"permalink":"/posts/me_aburro_testeando/","section":"Publicaciones","summary":"Si hacemos siempre lo mismo, es obvio que vamos a terminar por aburrirnos. Pero, ¿cuál es la solución entonces? Eso depende de vos, no existe una fórmula mágica o paso a paso a seguir para llevar tu Testing al otro nivel. Lo que puedo asegurarte, es que si llegaste hasta acá, significa al menos te preocupa no aburrirte en tu profesión, aunque la verdadera pregunta sería ¿Qué tan en serio te tomás tu profesión?","title":"Me aburro testeando","type":"posts"},{"content":"El otro día paseaba un rato por Linkedin cuando me encontré con un post al que no voy a hacer referencia directa para evitar desviar la importancia de lo que realmente quiero exponer.\nEl posteo incluía una captura de pantalla de Excel que contenía una serie de casos de prueba (estos que incluyen un paso a paso de acción a realizar y resultado esperado, junto con un campo de “estado” referenciando al resultado de la prueba). Estos casos de prueba eran dirigidos a realizar un Login dentro de lo que asumo era una página web.\nInmediatamente me vinieron recuerdos relacionados a mis creencias previas a comenzar una carrera en Testing, creencias basadas en mi poco conocimiento de la profesión, sumado a la desinformación, que lejos de ser poca, abunda. Desinformación que no sólo es impartida por desconocedores del rubro, si no que también es transmitida por los mismos Testers.\n¿A qué voy con todo esto? Bueno, esta persona que realizaba el posteo parecía orgullosa de haber creado un Excel en donde se describe cómo realizar un Login exitoso y uno fallido con ciertos datos de prueba, exclamando que esos eran sus primeros pasos en Testing.\nNo dejó de hacerme ruido y no es un ruido nuevo, para algunos puede que esto sea normal, y piensen verdaderamente que lo que está expresado en ese Excel es el resultado del trabajo del Tester y por consiguiente, pensaron que apoyar el progreso de esta persona era lo indicado.\nBueno, para bien o para mal no estoy dentro de este grupo de gente, no me malentiendan, todo aprendizaje es valorado, pero es hora de romper algunos mitos de nuestra profesión que parecen haber calado en lo más profundo de nuestra esencia.\nEl post en cuestión exclamaba “Diseñar casos de prueba es parte del día a día de un Tester” y creo que es una creencia común que tienen todas las personas que se inician en el sector, así como también muchas de las que ya ejercen el trabajo.\nNuestra industria tiene una clara obsesión con los “casos de prueba”, pero no solo eso, sino que estos casos de prueba están concebidos como el resultado de nuestro trabajo y esto se ve reflejado tanto en las expectativas de nuestros clientes como de supervisores, compañeros y gente iniciante.\nCuando escuchamos las razones por las cuales hay que basar nuestro trabajo en casos de prueba, todo nos lleva a la conclusión de que “es una buena práctica”, nos convencemos de que es lo correcto, entonces, partiendo de una buena intención, terminamos cediendo ante la concepción común, pero ¿Es realmente este el resultado de nuestro trabajo?\nEs común pensar que sea el resultado de nuestro trabajo, después de todo, el resultado del trabajo de un programador es código ¿Verdad? Entonces el resultado del trabajo de un Tester han de ser los casos de prueba.\nHay situaciones en la que es útil tener un paso a paso de chequeos en pruebas, como por ejemplo, para luego poder automatizar dichos chequeos, de esta forma le delegamos la tarea a una máquina. O quizás deseamos realizar una prueba en la que este formato nos facilita el labor.\nDespués de todo, el problema no son los casos de prueba… Así como en posteos anteriores mencioné que no existe el Testing Automatizado, tampoco existe el Testing Manual cuyo trabajo parecería consistir en codificar pruebas en un idioma no programático.\nTanto automatizar, cómo diseñar casos de prueba, son herramientas disponibles a la hora de desempeñar nuestro trabajo de la mejor forma posible, el problema, como mencioné anteriormente, radica en la obsesión.\nAsí como automatizar no es igual a Testear, diseñar y ejecutar casos de prueba tampoco lo es.\nEn esta forma de percibir el Testing, hay poco de aprender, desafiar, criticar y “jugar” con el producto. ¿A qué se debe esta obsesión entonces?\nEl primer motivo y el más común: la falta de confianza, los casos de prueba están estrictamente relacionados a la “evidencia”, que es una forma de “protegernos” por si algo de lo que probamos falla en un futuro, y necesitemos comprobar que las pruebas hayan cubierto el escenario.\nNadie revisa la evidencia cuando “todo sale bien”, otro gran problema. Personalmente no veo el beneficio en evidencias de cada cosa que hacemos, ningún problema es resuelto, la evidencia no dirá quién ocasionó el problema y tampoco ayudará a arreglarlo, y aunque el escenario no hubiese sido cubierto, la calidad no es responsabilidad pura y exclusivamente del Tester.\nOtro de los aparentes motivos de este enfoque; en palabras de James Bach y Aaron Hodder (“Test cases are not Testing”):\n“Uno de los supuestos beneficios del enfoque basado en casos de prueba es que la consistencia y repetibilidad están asegurados”\nMás tarde en el mismo artículo, Aaron muestra un experimento realizado en una clase de Testing, en dónde 6 alumnos fueron provistos de la misma serie de casos de prueba e indicaciones. Lejos de lo esperado, luego de que los alumnos ejecutaran los casos, se vió cómo todos habían obtenido resultados distintos, desmintiendo la anterior afirmación.\n¿Por qué pasa esto? Según los autores, porque cada tester tiene su propio juicio y heurísticas. Es decir, incluso aunque un colega pueda entender los casos que creamos, no significa que vaya a obtener los mismos resultados, no da igual quien pruebe.\nObtener métricas es otra de las excusas, management quiere saber de X cantidad de casos de prueba, cuántos “pasaron” vs cuántos fallaron, pero aunque un reporte indique que fallaron 2/100 y otro que fallaron 14/100 ¿Cómo podemos saber en base a números qué tan importantes son los casos que fallaron? ¿Qué clase de accionable o conclusión surge de dichos números?\nIncluso cuando no se hubieran encontrado bugs ¿Podríamos estar tranquilos? ¿Acaso esto significa que nuestro producto es de gran calidad?\nTodo nos lleva a que Testing es una performance, los Testers tienen como objetivo principal encontrar bugs, pero no podemos asegurar que hayamos encontrado todos los bugs, por lo tanto, las conclusiones que un Tester pueda obtener a partir de un producto se relacionan fuertemente a su experiencia, capacidad y conocimientos.\nEntonces, si el Testing depende de quién lo realiza, todo depende de la credibilidad del realizador, del Tester. No es algo tan sencillo como escribir casos de prueba ya que al final del día importa mucho más quién es el que prueba, que la prueba en sí misma.\nAsí como mencionan los autores previamente citados, el Testing no puede ser codificado, no podemos trasladar todo nuestro conocimiento e ideas sobre el producto a un texto explicativo. Incluso si pudiésemos, la información sería tanta que terminaría por ser inservible.\nPodemos entender entonces, que un caso de prueba o test es simplemente una porción de lo que hacemos. Ya que Testing ocupa desde las etapas más iniciales del desarrollo hasta la exploración e interacción con el producto, ya sea para verificar un flujo complejo o la simple respuesta de una función.\nLa mayor cantidad de ejecuciones de “casos de prueba” surgen cuando un Tester está interactuando con el producto, reflexionando, probando, dudando, observando. Los problemas no están únicamente en los caminos que definimos en dichos “casos de prueba”, de hecho, si así fuera, los Testers no existiríamos en equipos cuyos desarrolladores sean tan buenos que cumplan con todos los requerimientos a la hora de entregar un desarrollo.\nAún así, nos condenamos nosotros mismos a utilizar las mismas herramientas una y otra vez sin importar el contexto.\nSi encontramos un bug en donde la secuencia de acciones que realizamos no está descrita por un caso de prueba ¿Significa que no fui tan buen Tester para redactar dicho caso? ¿O significa que estoy haciendo lo que tengo que hacer realmente pero codificar o escribir todo lo que pienso probar está entorpeciendo mi verdadero trabajo?\nMis ideas no son nuevas, el artículo que cité (“Test cases are not Testing”) es de Febrero de 2014 y aún hoy en día, esta particularidad de nuestra profesión no es desafiada o llevada a juicio, no al menos en la mayor parte de la comunidad.\nEn conclusión, ni los casos de prueba son malos, ni el Testing es igual a escribir y ejecutar casos de prueba. Podemos hacer un seguimiento de nuestras pruebas e ideas sin necesidad de hacer de todo una explicación, podemos Testear sin escribir un caso de prueba de cada pequeña acción que realizamos.\nEl miedo de no poder controlar, documentar o mostrar el resultado de cada pequeña acción que realizamos sobre un producto es entendible. La mayoría de la gente pareciera asumir que el Testing se basa en eso, si seguimos vendiendo la ilusión que los casos de prueba son Testing y no parte de Testing, entonces estamos condenados a tener que basar nuestra profesión en ellos, y que en lugar de ser una herramienta, sean nuestro trabajo:\nEjecutar, evidenciar y reportar lo que nuestros limitados casos de prueba nos dicten.\n","date":"13 de junio de 2024","externalUrl":null,"permalink":"/posts/testear_no_es_hacer_casos_de_prueba/","section":"Publicaciones","summary":"Nuestra industria tiene una clara obsesión con los “casos de prueba”, pero no solo eso, sino que estos casos de prueba están concebidos como el resultado de nuestro trabajo y esto se ve reflejado tanto en las expectativas de nuestros clientes como de supervisores, compañeros y gente iniciante.","title":"Testear no es hacer casos de prueba","type":"posts"},{"content":"Seamos sinceros, tal como lo dice el título ¿Existe la posibilidad de automatizar el proceso de Testing?\nLa primera pregunta que me hago es ¿A qué llamamos Testing? Ya que dependiendo del concepto que cada uno tenga, la respuesta puede ser una u otra.\nHay varias definiciones, es cosa buscar y quedarse con la que uno cree que mejor representa su trabajo. En mi caso me quedo con una definición combinada: “Testing es aprender del producto en nombre de otras personas, para evitar que les ocurran problemas a ellos y a las personas que le importan, a su vez, su resultado debe ser poder comunicar el estado del producto a demanda”.\nAhora ¿Puedo aprender de forma automatizada por otras personas? No, si bien hoy en día cada vez más escuchamos acerca de la “inteligencia artificial”, actualmente los seres humanos somos los únicos capaces de relacionar y contextualizar diversos tópicos de los cuales se compone un proyecto para aprender de diversas fuentes de forma efectiva.\nY qué hay de ¿Comunicar el estado del producto a demanda? Acá está el problema, si bien un script puede ejecutar flujos de forma automática, esto no es ni de cerca el trabajo que realiza un Tester. Los resultados de dichas automatizaciones pueden servir en parte para aumentar el nivel de confianza en un sistema, pero incluso si los resultados dieran OK ¿Podríamos estar seguros que no existen errores dentro de nuestro sistema? No, ya que es imposible automatizar cada aspecto de nuestro trabajo.\nNosotros, como Testers sabemos que nuestras automatizaciones no cubren todo el sistema e incluso si lo hiciera, corremos el riesgo de haber cometido errores en nuestro código, es una paradoja, escribimos código que pruebe otro código para chequear el correcto funcionamiento del mismo, pero ningún código chequea el comportamiento de nuestro código, es un problema sin fin.\nDe todos modos alguien podría decir algo como… “se están apretando cosas automáticamente y chequeando sus resultados, eso es lo que haría un tester, por eso se le llama Testing automatizado”. (Es uno de los muchos ejemplos de automatizaciones)\n¿Es esto cierto? Según mi definición, eso no es Testing, no estoy aprendiendo nada del producto ni estoy seguro de poder comunicar el estado del mismo basándose única y exclusivamente en el resultado de dichas automatizaciones.\nPero debo reconocer que para mucha gente hacer Testing no es más que chequear outputs de un sistema, en esa concepción podría llegar a tener sentido, pero incluso así, recordemos el punto anterior, ningún código chequea el comportamiento de nuestro código, por lo tanto podemos tener errores automatizados.\nAhora, si un script realiza chequeos automáticos por nosotros ¿Es eso Testing Automatizado incluso bajo una concepción errónea de nuestro trabajo? Yo creo que no, ya que aún cuando un Tester decide automatizar un proceso, no es algo tan simple como “me gustaría chequear flujos de forma automática” y pum aparece un script milagrosamente.\nSe necesita hacer un análisis del sistema a ser “automatizado”, analizando no solo el tiempo que te ahorraría la automatización, sino también los riesgos que esta conlleva, elección de un framework, análisis de la solución, documentación de la misma, su mantenimiento, su escalabilidad, su viabilidad, relación tiempo de desarrollo vs valor generado, entender si es el momento adecuado para el desarrollo de la misma, disponibilidad para su desarrollo, entre las que se me ocurren ahora mismo.\nLa resolución de todas las tareas anteriormente mencionadas serían realizadas por el Tester a cargo del área en un proyecto. Suponiendo que finalmente se crearon las automatizaciones deseadas ¿Significa entonces que prescindimos del Tester ya que su trabajo ya está automatizado? No…\nIncluso cuando se hagan chequeos automáticos, hay que saber interpretar y analizar los resultados, los sistemas cambian, por lo tanto habría que realizar cambios en el código, si el sistema no cambiase no haría falta automatizar nada ya que el sistema sería una constante y no tendría sentido automatizar chequeos sobre algo estático.\n¿Estoy admitiendo entonces que eso es Testing automatizado? Como habrás notado a lo largo de mi descargo, siempre me referí al resultado de la automatización como “chequeos” es decir, corroboraciones que hace un script automáticamente, como lo pueden ser “X cosa es igual a Y cosa”, o “X cosa es mayor que Y cosa”.\nEso es todo, chequeos, y son muy útiles, realizar chequeos automáticamente que de otra forma nos demandarían mucho tiempo, es genial ¿Por qué? Porque nos libera tiempo para poder centrarnos en cosas más profundas o importantes que van más allá de verificar outputs como máquinas.\nVolvamos al eje de la discusión una vez más, esta vez con una analogía, supongamos que un jardinero corta el pasto con una máquina de cortar pasto ¿Está esta persona realizando jardinería automatizada? O mejor pensemos en un desarrollador el cual recibe asistencia de una herramienta para mejorar o crear su código ¿Es esto desarrollo automatizado? Creo que ven cual es el punto.\nQue una herramienta te ayude en parte de tu trabajo, no significa que te reemplace ni que haga el trabajo por vos, simplemente son eso, herramientas que te facilitan trabajos, ni más ni menos. El trabajo que automatizan no es el Testing per se, es un aspecto del Testing.\nComo conclusión quiero que te lleves que el Testing no es automatizable en mi opinión, generar conocimiento y relevar el estado de un producto a demanda no es algo que pueda hacer una máquina hoy en día, sin embargo, creo que existe un gran valor en la creación de herramientas que nos pueden servir a los Testers para hacer nuestro trabajo más eficiente o eficaz.\nSi bien solamente les hablé de automatizaciones para chequeos, las automatizaciones existen para muchas más cosas, así como lo pueden ser la generación de datos y la obtención de los mismo, tema que puede que trate en otro post.\nHay que revalorizar nuestro trabajo, sin venderlo como algo reemplazable por una máquina, sino como algo que se apoya en máquinas para realizar un trabajo más completo.\nEl valor siempre va a estar en la capacidad que tenga un Tester de usar su cerebro para ser crítico con un sistema, encontrar esos huecos funcionales, esos detalles que a uno le generan un ruido interno, esas intuiciones que lo llevan a descubrir errores, esa experiencia que lo ayuda a evitar tropezar con rocas del pasado. No dejemos que nuestro trabajo sea visto como un mero chequeo automatizado.\nAbrazo grande y buen Testing!\n","date":"20 de mayo de 2024","externalUrl":null,"permalink":"/posts/existe_el_testing_automatizado/","section":"Publicaciones","summary":"Si bien un script puede ejecutar flujos de forma automática, esto no es ni de cerca el trabajo que realiza un Tester. Los resultados de dichas automatizaciones pueden servir en parte para aumentar el nivel de confianza en un sistema, pero incluso si los resultados dieran OK ¿Podríamos estar seguros que no existen errores dentro de nuestro sistema? No, ya que es imposible automatizar cada aspecto de nuestro trabajo.","title":"¿Existe el Testing Automatizado?","type":"posts"},{"content":"En algún momento de nuestra carrera entramos en un nuevo proyecto, es desafiante comenzar en un nuevo lugar del cual desconocemos todo, esto último puede ser muy abrumador, por eso, basándome en mi experiencia quiero que nos planteemos en qué cosas enfocarnos para salir a flote y no hundirnos en el intento.\nLos invito a pensar en un proyecto como si fuera una casa, que tiene sus cimientos, su estructura, su gente, sus costumbres, su organización, puntos fuertes y débiles.\nBajo esta analogía podemos entender que al estar por primera vez en un lugar es normal perdernos un poco, aunque rápidamente nos vamos a ir sintiendo más y más cómodos.\nVale la pena aclarar que el nuevo proyecto en ocasiones puede no ser una casa, si no un rascacielos, un laberinto o un museo que carece de guía.\nNo empieces con un plan # No me malentiendas, planificar es importante, pero primero hay que entender dónde estamos parados, para esto podés hacerte a vos mismo y al equipo algunas de estas preguntas:\n¿Qué información tengo disponible? (Del proyecto en sí y de lo que involucre a mi trabajo) ¿En qué etapa del proyecto estamos? ¿Qué tan seguido se hacen avances? ¿Qué tan largos son nuestros sprints? (Si aplica) ¿Hay algún hito cerca? ¿Cuándo es la próxima entrega? ¿Hubo algún cambio recientemente? ¿Cuál es mi misión? ¿Quiénes son mis stakeholders? ¿Existe algo que el cliente quiera de mí específicamente? (Entregables, demostraciones) ¿Qué necesito saber? ¿A quién debo preguntar? ¿A quién reporto/informo mis avances? Existen muchas más preguntas y podría hacerse una lista interminable, pero considero que estas son independientes del contexto y a raíz de la información que obtengas del proyecto podrás reforzarlas como creas conveniente.\nTanto en el libro “The Lean Startup” como en muchos libros más se toca un tema que considero muy útil en ocasiones de gran incertidumbre así como lo es iniciarse en un proyecto, y este tema es “lograr entender lo que nuestros usuarios desean”, en nuestro caso los usuarios serían nuestros clientes o stakeholders.\nNo es tarea sencilla dar en el blanco, pero la idea no es esa, la idea es partir de una hipótesis, realizar acciones que busquen validar nuestra idea y a partir de eso analizar los resultados obtenidos.\nSupongamos que nuestra hipótesis es que el cliente está necesitando más documentación para entender el producto que estamos creando, entonces pasamos horas y horas creando una documentación extensa y detallada. Una vez que terminamos el documento que nos llevó horas y horas terminar, lo presentamos al cliente y SORPRESA, o no tan sorpresa… Nadie terminó leyendo el documento.\n¿Por qué? Porque no habíamos validado nuestra idea.\nEl MVP o Minimum Viable Product es algo que se aplica en la vida diaria y es algo de lo que tenemos que aprender. Antes de pasar horas y horas llevando a cabo una tarea de la cuál no estamos seguros que realmente sea beneficiosa para el proyecto, lo que podríamos haber hecho es hacer una pequeña parte de la documentación, ver cómo reaccionaba el cliente ante esta idea, validar que sea un documento que aporte valor como nosotros sospechábamos, analizar si está siendo usado o no, y una vez hecho dicho análisis previo, podemos deducir que terminar de realizar nuestra tarea tiene sentido.\nLa idea es no malgastar nuestro tiempo y energía en responsabilidades autoimpuestas y no validadas, hay que buscar aprender de nuestros compañeros y de la información que haya disponible lo más rápido posible.\n¿Cómo “aprender” rápido? # Si existe una habilidad imprescindible para este escenario en el que estamos parados es la capacidad de aprender. La forma que me es más útil personalmente a la hora de adquirir nuevos conocimientos son las sesiones.\nLas sesiones son llamadas de voz con tus compañeros de equipo que tengan una duración tal que dé lugar a explicaciones detalladas y repreguntas. Recomiendo grabar estas sesiones iniciales ya que toda la información que obtengas de las mismas será nueva, por consiguiente, será difícil por no decir imposible acordarse de todo lo que se charló.\nEscuchar no alcanza, cuando estés en una sesión lo ideal es estar activo en todo momento, no guardarse preguntas o quedarse con dudas, demostrar interés e intentar explicar con tus palabras lo que tu compañero te está intentando explicar a vos. Demostrar interés va a ayudar a que la otra persona se sienta con ganas de enseñarte y responder a tus dudas. Explicar con tus palabras los temas que se estén tratando te ayudará a validar tu entendimiento del tópico, brindándote la seguridad necesaria para comenzar con tus tareas.\nOtra de las cosas que pueden ser de gran utilidad son los diagramas de flujos de los procesos que involucren a la solución del problema (en caso de que aplique para tu proyecto), si no existe dicho diagrama, crearlo no solo ayudará a todo el equipo, si no que también será un elemento clave que te permita plasmar de forma gráfica todo el conocimiento que fuiste adquiriendo durante las sesiones.\nNo pierdas demasiado tiempo únicamente leyendo y leyendo documentación, experimentá el producto con tus propias manos, ahí es dónde van a surgir las mayores dudas, luego podés usar la documentación o las sesiones para aclarar todas esas dudas, aprendemos mucho más haciendo que viendo o escuchando.\nRealiza todas las anotaciones que creas convenientes, generalmente, cuando sos nuevo en un lugar, van a surgir muchas cuestiones que vale la pena anotar, si bien la idea es grabar en mayor parte tus conversaciones, tomar notas sobre la marcha te va a ayudar a no realizar un doble trabajo cada vez que grabes algo, estas anotaciones pueden ser luego clasificadas.\nLa forma de organizar tus notas es totalmente personal, por mi parte y mi rol de Tester, suelo crear algunos archivos cómo “riesgos”, “ideas de pruebas”, “temas a consultar”, lo importante es no crear algo inmantenible o inútil. Pensá que vas a tener que dar seguimiento posiblemente a tus anotaciones.\nHace que tu tiempo valga la pena # Ya pasaste horas en sesiones, ya aprendiste mucho acerca del producto, ya tuviste contacto con el mismo, ya es suficiente. No hay que esperar a ser un experto en todo sentido del producto para poder aportar valor, lo importante es tener en claro cómo debería de comportarse él mismo bajo distintas situaciones, y te lo aseguro, vas a necesitar preguntar más cosas en el futuro, así que manos a la obra.\nPara que tu tiempo valga la pena tenés que llevar algún tipo de registro de tus actividades y conocimiento, así como grabamos las sesiones debemos anotar aquellas cosas que nos generan dudas o bien encontramos que están erradas. Pero no basta con anotar y anotar una y otra vez, cada cierto tiempo deberías juntarte con algún miembro del equipo para rever estas anotaciones, darles un estado.\nNo siempre habrá una respuesta clara y una acción inmediata a tomar en base a nuestras dudas, a no desesperarse y mantener el registro allí, lo importante es no perder de vista aquellas cosas que encontramos para que cuando más adelante las crucemos nuevamente no sean algo desconocido de lo que debamos volver a preguntar.\nEl tiempo vuela, todo es nuevo para nosotros, tenemos energía extra pero no significa que todos estén en nuestra misma sintonía, cuando tengamos momentos de soledad debemos aprovecharlos para volver sobre las grabaciones de las sesiones, las notas y todo aquello en lo que sentimos que estamos flaqueando. Es normal no sentirse cien por ciento seguro de tu conocimiento al principio, lo importante es no dejar de registrar tus pensamientos ya que si caes en ese lugar de incertidumbre nuevamente es posible que te lleve la corriente y ahí se cumpla verdaderamente tu temor de no entender lo que está pasando en el proyecto.\nPara concluir # Con “morir en el intento” me refiero a perderte en ese laberinto, no aprender nada de ese museo sin guía o sentir vértigo en el rascacielos. Hay que acostumbrarse a los proyectos, pero no perder el interés por entender y aprender de ellos cada día un poco más, no quedarnos con esa pequeña parte que nos involucra y ya.\nEn mi paso por distintos proyectos fui aprendiendo distintas cosas y entendiendo muchas otras, lo importante es llevarte algo de la experiencia y que no sea un mero registro. Si bien este artículo no fue una guía extensa, no existe dicha guía, cada proyecto es un mundo, lo importante es afrontarlo y no morir en el intento.\nAferrate de tus ganas de aprender y no dejes que muera esa chispa, el día de mañana quizás seas vos el guía de ese museo o el maestro de ese laberinto, te deseo mucha suerte.\nAbrazo grande, Nacho.\n","date":"4 de marzo de 2024","externalUrl":null,"permalink":"/posts/como_afrontar_un_nuevo_proyecto_y_no_morir_en_el_intento/","section":"Publicaciones","summary":"En algún momento de nuestra carrera entramos en un nuevo proyecto, es desafiante comenzar en un nuevo lugar del cual desconocemos todo, esto último puede ser muy abrumador, por eso, basándome en mi experiencia quiero que nos planteemos en qué cosas enfocarnos para salir a flote y no hundirnos en el intento. Los invito a pensar en un proyecto como si fuera una casa, que tiene sus cimientos, su estructura, su gente, sus costumbres, su organización, puntos fuertes y débiles.","title":"Cómo afrontar un nuevo proyecto y no morir en el intento","type":"posts"},{"content":"La comunicación nos interpela en todo sentido y casi todo contexto, sin embargo, es algo que nadie nos enseña. Poder compartir nuestras ideas así como asimilar las ideas ajenas es esencial para desarrollar nuestro trabajo de la forma más efectiva posible. Un rol que se basa en entender cómo debería funcionar un producto, comunicar el estado del mismo, reportar incidencias, sugerir mejoras, entre muchas otras cosas más, nos exige que vayamos puliendo nuestra comunicación.\nMencionaré algunas de las cosas que me sirven para ser más efectivo en mi trabajo, pero considero que son beneficiosas para todos los roles.\nRepetir lo que nos explican # Cualquiera que sea el puesto que ocupemos dentro de un proyecto, nuestro desempeño se verá altamente influenciado por lo que el resto del equipo pueda aportarnos, desde conocimiento propio del producto hasta información relevante que nos ayudará en nuestras tareas, lo cual significa, muchas horas de escuchar y escuchar explicaciones.\nSi son cómo yo y consumen muchos videos de Youtube o cualquier otra red, se habrán dado cuenta que pueden ver videos de horas y horas sobre temas interesantísimos y luego no haber aprendido nada…O remontémonos al colegio, cuando pensábamos que habíamos entendido todo y después nos sorprendíamos cuando las cosas no salían como esperábamos.\nRepetir lo que nos explican es la forma no solo de demostrar que estamos prestando suma atención a lo que nos están contando, sino que también de practicar la escucha activa. Cuando digo “repetir” no me refiero a ser un loro que memoriza y repite, es un poco más complejo que eso, la idea es poder “traducir” lo que nos cuentan, no siempre vamos a entender todo lo que nos están diciendo, pero es importante ser capaces de quedarnos con lo más importante incluso cuando no estamos seguros de todos los pasos o tecnicismos que puedan involucrarse en la explicación.\nPor ejemplo, supongamos que una persona nos está explicando el flujo de un sistema el cual desconocemos por completo, cuando creamos conveniente haremos una pausa y le comunicaremos a la otra persona algo como “¿Te molestaría que te repita lo que entendí de tu explicación para ver si estoy entendiendo correctamente?” De esta forma la otra persona puede corregir aspectos los cuales vos hayas asumido o malinterpretado, ayudando a ambos a estar en la misma página.\nExplicar las cosas sin asumir que el otro entiende de lo que hablamos # Son demasiadas las veces que observo o soy partícipe de una conversación en dónde alguien asume inconscientemente que la otra persona es como él. Asumir cosas es normal, es humano hacer asunciones para simplificar una conversación pero es un arma de doble filo.\nA modo de analogía, para que dos personas puedan comunicarse deben hablar el mismo idioma, entonces, no vale la pena explicar algo de la forma más correcta o técnica posible si hay pérdida de entendimiento de por medio debido a que la otra persona no habla este “idioma”.\n¿Cómo saber si la otra persona me va a entender? No es muy difícil, la idea es que la otra persona no sienta vergüenza de no saber algo, comunicarle a la misma que por favor te frene si no conoce algún término de todo lo que estás diciendo, y no solo eso, podes hacer preguntas para saber qué tanto conocimiento tiene la otra persona sobre el tema que estás por abordar, ¿Qué tanto conoces de X? ¿Escuchaste hablar alguna vez de Y? ¿Te tocó trabajar con Z alguna vez?\nNo queremos hacer de nuestra comunicación un monólogo, hacer pausas y preguntas para corroborar que la otra parte esté en sintonía es vital, imaginemos que la otra persona tiene que recorrer un camino que lo lleve desde “no entiendo lo que me queres decir” a “entiendo claramente lo que me querés comunicar”, en este camino hay muchas piedras y pozos que dificultan todo, y por eso, no hay limitación impuesta que nos impida hacernos entender, ¿A qué voy con esto?\nHaz cualquier cosa que pueda ayudar a la otra persona a entenderte, personalmente suelo hacer uso de analogías en ocasiones así como también utilizo alguna que otra herramienta para dibujar como Paint lo que me permite diagramar mis ideas o pensamientos y aclarar tópicos que son difíciles de “dibujar en el aire”, más aún cuando la comunicación es mediante una llamada.\nPor último diría que expliques las cosas cómo te hubiese gustado que te las expliquen a vos, no me refiero a “de la misma manera” pero por ahí hay algo que a vos no te quedaba claro la primera vez que oíste de cierto tema y puede que la otra persona pase por lo mismo, es común olvidar, pero no olvidemos que una vez estuvimos en el mismo lugar que el otro y tuvimos que aprenderlo de una forma u otra.\nEl contexto lo es todo # ¿Es el momento de tener esta conversación? Si la respuesta es sí, adelante, pero no hay que olvidarse nunca con quién estamos hablando, cada persona tiene distintos intereses, no le va a interesar lo mismo a tu compañero Tester, al líder del proyecto, o al jefe del equipo del cliente, cada persona quiere escuchar una parte de la historia y es nuestra tarea es en parte identificar los elementos de interés para cada una de ellas, es decir, puede que al jefe del equipo del cliente no le interese saber en detalle por qué apareció ese bug que rompió el sistema, sino más bien cuánto tiempo se va a necesitar para resolverlo. Usando el mismo ejemplo, al desarrollador sí le interesará conocer más en detalle el reporte del bug y cómo reproducirlo.\nAsí como el contexto es importante para ver que parte de la historia contamos y cuál no, nuestro segundo peor enemigo es “irse por las ramas”, si estamos hablando de la parte X de nuestro discurso intentemos no irnos por las ramas a la parte Y, entendamos que a la otra persona no puede interesarle, sí tenemos miedo de omitir información que para nosotros es importante, podemos preguntarlo… “¿Te interesaría que veamos X parte del tema?” o “¿Qué parte del tema te interesa realmente?”\nDe la misma forma, cuando otra persona nos está hablando de algo que nos interesa y se está yendo por las ramas, hay que tener el tacto y la consciencia de avisarlo para poder retomar el punto central de la conversación, no vale la pena llenar tu mente de información irrelevante de Y, Z cuando vos venías buscando saber más de X.\nSi bien la otra persona puede tener distintos intereses a los nuestros no por esto debemos dejar de explicar nuestro trabajo. Volviendo a la situación anterior, imaginemos que estamos reportando al jefe del cliente y entendemos que este solo quiere saber cuánto tiempo tardará el resolverse la incidencia, no por eso vamos a evitar contarle los esfuerzos que estamos haciendo para que esto no vuelva a suceder o el gran trabajo que se hizo para encontrar el problema y traerlo a la mesa. Personalmente creo que no hay cosa que genere más confianza que hablar con una persona que está dispuesta a explicarte un tema teniendo en cuenta tus necesidades y preocupaciones.\nPonele voluntad # Todos pasamos por situaciones en las que tenemos muchas dudas sobre temas y queremos mandar un mensaje con 999 preguntas para clarificar nuestras dudas. No lo hagas, no de esta forma.\nSon incontables las veces que he preguntado más de una cosa a la vez y recibí parte de la respuesta, pero también hay que ser autocríticos y preguntar lo esencial, no queremos abrumar a todo el mundo, de ser posible quizás la mejor solución sea una breve llamada, la cual podes grabar y repasar cuantas veces quieras.\nNo me malinterpretes, sacarse las dudas es clave y hacer preguntas es imprescindible, pero para llegar a conseguir las respuestas que queremos tenemos que ponerle voluntad, nada peor que recibir preguntas que demuestran que no se hizo una mínima investigación previa o pensamiento crítico.\nSi hay algo de lo que no sabemos seamos capaces de reconocerlo y hacer un mínimo de investigación previo antes de ir a consultarlo todo a un compañero, esto no sólo te ayudará a tener un pantallazo sobre cierto tema o cuestión, si no que también le hará ver a la otra persona que valoras su tiempo y estuviste buscando algo antes de ir a golpearle la puerta.\nComo mencioné previamente, el contexto lo es todo, no te digo que hagas esto siempre, hay ocasiones que ameritan preguntar lo googleable y está perfecto, esto va más de la mano con la percepción que queremos que el resto tenga de nosotros a la hora de recibir un mensaje. Queremos que digan “¿Otra vez este/a?” O queremos que estén dispuestos a responder nuestras dudas sabiendo que estamos haciendo las preguntas correctas y demostrando interés genuino.\nPara concluir # Espero haberme expresado de forma clara, de lo contrario este artículo perdería cualquier tipo de validez.\nDejando el chiste de lado, estos no son mandamientos ni “mejores prácticas”, se basan puramente en mi experiencia personal y pueden estar sesgados por mi forma de percibir las relaciones, de todas formas espero que hayas aprendido algo nuevo o validado tu conocimiento.\nAbrazo grande, Nacho.\n","date":"14 de febrero de 2024","externalUrl":null,"permalink":"/posts/algunos_puntos_para_una_mejor_comunicacion/","section":"Publicaciones","summary":"La comunicación nos interpela en todo sentido y casi todo contexto, sin embargo, es algo que nadie nos enseña. Poder compartir nuestras ideas así como asimilar las ideas ajenas es esencial para desarrollar nuestro trabajo de la forma más efectiva posible. Un rol que se basa en entender cómo debería funcionar un producto, comunicar el estado del mismo, reportar incidencias, sugerir mejoras, entre muchas otras cosas más, nos exige que vayamos puliendo nuestra comunicación.","title":"Algunos puntos para una mejor comunicación","type":"posts"},{"content":"Caí en la trampa… Así como yo caí en la trampa, puede que varios de mis colegas también lo hayan hecho y dudo que esto vaya a cambiar en un futuro cercano.\nCuando ingresé al mundo del Testing creí como muchos otros que existía una diferencia clave entre hacer Testing Manual y Testing Automatizado: “El Tester Automatizador se encarga de crear scripts que realicen las mismas acciones que un Tester Manual para así ahorrarse el trabajo de tener que correr las pruebas manualmente”.\nBajo este pensamiento es obvio que yo no quiera tener que realizar pruebas manuales, si sé programar ¿Por qué perder el tiempo en correr pruebas que podrían ser automatizadas?\nNo podía estar más equivocado en tantas cosas al mismo tiempo, se podría decir que es un error querer diferenciar al Tester por \u0026ldquo;Automatizador\u0026rdquo; o \u0026ldquo;Manual\u0026rdquo;, aunque por X o por Y ya nos hemos acostumbrado a dichos términos.\nLo que voy a plantear no es una idea nueva, sino más bien una reflexión a partir de la palabra de un Tester con muchísima más experiencia en el campo que yo como lo es James Bach.\nVayamos a la parte visible del problema y qué mejor forma de hacerlo que con una analogía inicial.\nNuestro Título # Supongamos que un desarrollador de software está buscando trabajo y como existen muchos tipos de puestos y necesidades dentro del mundo del desarrollo decide especificar más sobre qué tipo de trabajo realiza, entonces agrega una etiqueta más a su título, por ejemplo \u0026ldquo;Desarrollador Backend\u0026rdquo;.\nLeyendo su título entendemos este desarrollador se dedica a programar en X lenguaje y sabemos que está especializado en Backend, posiblemente trabaje en la construcción de APIs, base de datos, etc. Podemos imaginarnos o hacernos la idea de por dónde va la cuestión.\nPero cuando hablamos de Testing, no solemos etiquetarnos de dicha forma… “Tester Backend” si no que solemos categorizarnos como “Manual” o “Automation” en mayor medida.\nPero ¿Qué es realmente ser un “Tester Manual”?\nQuizás para las personas menos abocadas al rubro esto haga referencia a que tal como dice el título, el Tester Manual “solamente” realiza pruebas haciendo uso de sus manos como si nos remontásemos a la revolución industrial y nuestro trabajo consistiese en tocar botones y corroborar resultados… Siguiendo este pensamiento es allí donde llegaría el Testing Automatizado, el cual viene a presionar dichos botones y comprobar dichos resultados por nosotros, haciendo el trabajo por nosotros, o mejor dicho, haciendo nuestro trabajo.\nSi bien es cierto que el Testing Manual hace referencia a la carencia de herramientas de automatización esto no debería ser una etiqueta y déjame explicar el por qué.\nLos Testers tanto “Manuales” como “Automatizadores”, ya sean especialistas o generalistas deben tener un set de habilidades y características que les permita desarrollarse exitosamente en un proyecto, así como lo son el pensamiento crítico, la comunicación, la investigación, la exploración, la curiosidad, entre muchas otras cosas más.\nSi pensamos al Testing como una actividad que busca generar un profundo conocimiento del producto para poder comunicar el estado actual del mismo a demanda, categorizar nuestro trabajo de dicha forma carece de sentido.\nNo solo estamos ignorando el verdadero propósito de nuestro trabajo si no que vamos un paso más allá y queremos reinventar la rueda llamando a un programador “Tester Automatizador”, y déjenme ser claro en esto, no hay ningún problema en automatizar aspectos del Testing, como lo puede ser el chequeo automático de output pero utilizar una etiqueta como esta puede llevar a malas interpretaciones que conduzcan a las personas a pensar que el Testing se puede automatizar.\nY no, hoy en día no sé puede automatizar todos los aspectos de un Tester a la hora de hacer una prueba: verificaciones, razonamientos, dudas, intuiciones, análisis, conclusiones, no son automatizables por completo. No al menos hasta que la IA llegue a la “singularidad” pero eso es tema para otro momento…\nAutomatizar hoy en día está visto en mayor parte como hacer clicks e inputs en una aplicación ya sea web o mobile para luego verificar que ciertas condiciones se cumplan tras haber realizado dichas acciones, bajo esta concepción entonces nos podemos preguntar: ¿Qué diferencia hay entre un Tester Automatizador y un desarrollador?\nNinguna, un desarrollador podría seguir un lineamiento para llegar a construir las mismas automatizaciones que se le demanden, y es más, lo hacen, o deberían de hacer diariamente cuando crean pruebas para testear el código que escriben.\nY si no me crees, pensá entonces qué se te viene a la cabeza cuándo alguien dice “Automatizar” en el rubro de Testing\u0026hellip; Posiblemente pienses en herramientas, Frameworks, programación. Y sí, estás en lo cierto, existen variedad de herramientas que facilitan nuestro trabajo dependiendo del objeto a testear, existen tantas que hay varias para cada propósito, web, mobile, apps de escritorio, servicios, UX y un sin fin. Entonces ¿Qué tipo de Automatizador sos? ¿Backend? ¿Frontend? ¿Se entiende el problema?\nLlamarte \u0026ldquo;Automatizador\u0026rdquo; no refleja una descripción más cercana a tus propósitos, si crees que automatizar es un propósito en sí mismo, entonces no estarías buscando un \u0026ldquo;Automatizador\u0026rdquo;, sino un programador o especialista en cierta herramienta.\nA lo que voy con todo esto es el vacío, la confusión y la banalización que generamos a la hora de utilizar estas etiquetas. Así como la palabra “Manual” no te da una pista de la especialidad o conocimiento de un Tester, la palabra “Automatizador” empeora lo anterior haciéndole creer al resto de áreas (y a veces a nuestro propia área) que nuestro trabajo es reemplazable por un script.\nUn Automatizador sin conocimientos de fondo de lo que está haciendo no va a generar más que scripts carentes de sentido, que si bien pueden pasar todos \u0026ldquo;en verde\u0026rdquo; y ser muy lindo a la vista, después no va a ayudar a aportar valor al producto.\nSinceramente dudo sobre todo aquel que se venda como \u0026ldquo;Automatizador\u0026rdquo; seriamente\u0026hellip;\nY viene de parte de alguien que se vende como Automatizador. ¿Entonces?\nConclusión # No todo es tan fácil como decir “dejemos de etiquetarnos así” y listo. Para el mercado un “Tester Automatizador” es como un Tester con esteroides, aunque podemos entender que no tiene por qué serlo, y un “Tester Manual” es un Tester que podría llegar a tener esos esteroides en un futuro. Y con mercado quiero ser claro, no solo me refiero a las empresas que crean búsquedas con dichos nombres, sino también a la otra parte, la oferta, que juega al mismo juego.\nSi bien mencioné que los términos son perjudiciales para nuestro área, actualmente es difícil cambiar la terminología cuando somos nosotros mismos quienes la impartimos para promocionar nuestras habilidades y conocimientos, por lo cual no esperaría que esto fuese a cambiar pronto. Al menos, en lo inmediato, podemos llevar claridad al resto de colegas sobre dicha categorización mediante charlas y debates sobre el tema.\nSi tuviera que dar una mirada final a todo esto, les diría que no se queden con la primer impresión de un Tester por un simple término como “Manual” o “Automation”, la calidad del trabajo y las capacidades que una persona puede llegar a tener no están impartidas por su conocimiento en programación o sobre una herramienta en particular, sino que están asociadas a las bases de nuestro trabajo, esas tareas las cuales no existe máquina que pueda con ellas, el uso de nuestra consciencia plena, nuestro razonamiento y pensamiento crítico en cada oportunidad que se nos presente.\n","date":"25 de enero de 2024","externalUrl":null,"permalink":"/posts/test_manual_vs_automatizado/","section":"Publicaciones","summary":"Los Testers tanto “Manuales” como “Automatizadores”, ya sean especialistas o generalistas deben tener un set de habilidades y características que les permita desarrollarse exitosamente en un proyecto, así como lo son el pensamiento crítico, la comunicación, la investigación, la exploración, la curiosidad, entre muchas otras cosas más. Si pensamos al Testing como una actividad que busca generar un profundo conocimiento del producto para poder comunicar el estado actual del mismo a demanda, categorizar nuestro trabajo de dicha forma carece de sentido.","title":"Testing Manual vs Automatizado","type":"posts"},{"content":"Poco después de haber dado mis primeros pasos en el mundo de las pruebas automatizadas escuché nombrar estos tres términos en conjunto por primera vez, mi acercamiento inicial me llevó a la misma conclusión que todos parecían tener, “Gherkin, BDD y Cucumber tienen algo que ver con Testing”, que debo decir, suena bastante convincente si tenemos en cuenta que al googlear obtenemos resultados de personas explicando como construir pruebas automatizadas, logrando así que nadie se cuestione el origen de dichos términos.\nPasaron los meses y el tema quedó allí, hasta que un día surgió ante mí la gran oportunidad de dar una presentación para mis colegas, no era una presentación cualquiera, era nada más y nada menos que una introducción a Gherkin, aquel lenguaje que hasta entonces creía conocer. Y he de decir que poco tiempo pasó antes de que cambie por completo el rumbo de mis creencias.\nSi es la primera vez que oís nombrar estos términos, no hay problema, aprenderás algo nuevo y de paso tendrás con qué desafiar las creencias de tus compañeros. Por otra parte, si ya los conoces y hasta has trabajado con ellos en Testing, puede que no te vaya a gustar lo que te voy a contar.\n¿Qué es Gherkin? # Gherkin o Pepinillo en su traducción al español, es en si un DSL, Lenguaje Específico de Dominio, esto significa que es un lenguaje que se creó específicamente para resolver un problema en particular proveyéndonos también de una técnica que nos permite solucionar dicho problema.\n¿Cuál es nuestro problema? La comunicación efectiva.\nLa comunicación entre las partes de un equipo siempre va a ser un problema, más específicamente la comunicación entre lo que se denominó posteriormente “The Three Amigos” es decir, el Product Owner (PO), el desarrollador y el tester. Ahora ¿Cómo nos ayuda este lenguaje a mejorar la comunicación entre dichas partes?\nPodría hacer un artículo entero sobre Gherkin, así que para simplificar las cosas solo haré uso de los elementos esenciales del lenguaje para que entendamos cómo se utiliza el mismo.\nGherkin nos provee 6 palabras clave:\nFeature (Característica, Funcionalidad): Funcionalidad del sistema. Background (Antecedentes): Precondiciones del escenario. Scenario (Escenario): Situación general. Given (Dado): Contexto de la situación. When (Cuando): Acción. Then (Entonces): Resultado esperado. Supongamos que el PO cita a los desarrolladores y a nosotros, testers, para presentarnos una nueva funcionalidad del sistema, la funcionalidad consiste en las posibilidades que tiene un usuario de publicar blogs en una página. Todos acordamos en utilizar Gherkin para describir los criterios de aceptación de nuestra funcionalidad para mejorar nuestra comunicación, por lo tanto luego de unos minutos de charla sobre lo presentado por el PO llegamos a un documento como el siguiente: (Voy a emplear Gherkin en español para facilitar la lectura)\nComo podemos observar, los escenarios no son más que situaciones o ejemplos que pueden darse en nuestra funcionalidad, y las palabras: Dado, Cuando, Entonces (Given, Then, When) nos ayudan a describir claramente lo que debería de suceder en cada una de estos casos.\n¿Quién lo redacta? Es indiferente, la idea es que todos los participantes, los “Three Amigos” tengan una charla fluida en la cual se presenten los criterios de aceptación iniciales y a partir de ahí puedan surgir más ideas y escenarios que se puedan evaluar en ese momento o que el PO se los lleve para rever con el cliente. Por dar un ejemplo, en este caso alguno de los integrantes podría preguntarse:\n¿Puede el administrador “Pepe” editar un artículo ya publicado por un usuario? o ¿Puede el administrador “Pepe” publicar en un blog de otro administrador?\nLa idea es intentar cubrir todos los casos que se nos vengan a la mente para que todos estemos de acuerdo en cómo debe comportarse nuestro sistema. ¿De qué nos ayuda tenerlo escrito de esta forma? Es un lenguaje natural y estructurado y fácil de entender por una persona técnica así como no técnica, es un estándar. Cualquier cliente podría entender los requerimientos sin ser un experto, digamos que hace que las especificaciones funcionales sean digeribles. Y la frutilla del postre, ayuda a que luego dichas frases puedan ser utilizadas como la base de automatizaciones, pero llegaremos allí luego.\n¿Qué origen tiene Gherkin? (Nacimiento de BDD) # Daniel Terhost-North Había una vez un desarollador con más de 20 años de experiencia en el rubro, este desarrollador lleva el nombre de Daniel Terhost-North. Dan formaba parte de un equipo el cual desarrollaba bajo la modalidad de TDD (Test Driven Development) (Desarrollo Guiado por Pruebas).\nTDD en pocas palabras busca basar nuestro desarrollo en pruebas que escribimos antes de escribir el código de nuestro sistema, por más confuso que suene, tiene sentido, supongamos que estamos diseñando una aplicación que tiene como funcionalidad la suma de dos numeros enteros:\n// Test de mi Sistema Operaciones_Suma_SumaDeEnterosExitosa: resultado = sumar(2,2) assert resultado == 4 // Funcionalidad de mi sistema Operaciones_Suma_SumaDeEnterosExitosa(numero_1,numero_2): return numero_1+numero_2 Entonces primero creariamos la función “Operaciones_Suma_SumaDeEnterosExitosa” y en base al comportamiento que debería seguir dicha funcionalidad, programaríamos la función de la cual hace uso “sumar”.\n(Se que es un ejemplo muy vago, pero mientras entiendas la idea me sobra)\nEl problema según la palabra de Dan radicaba en que seguía encontrándose con las mismas confusiones una y otra vez bajo este modelo: Por dónde empezar, qué testear y qué no testear, cuánto testear en un mismo test, cómo nombrar dichos tests, cómo entender por qué un test falla.\n(Cabe resaltar que TDD hace referencia a la etapa de desarrollo, es decir, tests escritos por los desarrolladores)\nTodo esto en resumidas cuentas lo impulsó a dar nacimiento a una nueva metodología “BDD” publicando su primer artículo al respecto “Introducing BDD” (Behaviour Driven Development) (Desarrollo Guiado por Comportamiento).\nSi en TDD los desarrolladores creaban scripts de pruebas que su código debía superar para así cercenarse de que su trabajo cumplía con la consigna, en BDD se creaban scripts de pruebas que el código debía superar de igual forma pero bajo la perspectiva del comportamiento del usuario. Si bien puede sonar algo confuso, lo vamos a entender cuando conectemos BDD con Gherkin.\nCabe aclarar que BDD no tiene relación en su nacimiento con Gherkin, si no que años después de nacer BDD, Daniel North junto con Chris Matts y Liz Keogh toman un template de requerimientos y lo convierten en un documento que hace uso de palabras claves en inglés así como vimos anteriormente, llevándonos así al nacimiento del primer template de Gherkin.\n¿Qué relación tiene Gherkin con BDD? # Como vimos anteriormente, Gherkin es sólo una forma de escribir requerimientos de un sistema y BDD es una metodología de desarrollo que consiste en escribir los tests basados en el comportamiento del usuario antes siquiera de escribir el código del sistema.\n¿Qué tiene que ver un documento funcional (Gherkin) con los tests que programen los desarrolladores para luego verificar su código (BDD)?\nAllí es donde entra Cucumber.\n¿Qué es Cucumber? # Cucumber logo Cucumber o Pepino en su traducción al español (sí, le pusieron así para hacer el juego entre Gherkin y Cucumber, ahora puede que entiendas por qué el artículo tiene una foto de pepinos…) es una herramienta creada por Aslak Hellesøy que ayuda a los desarrolladores a programar bajo la metodología BDD en distintos lenguajes, haciendo uso de tests redactados en Gherkin, lo sé, todo muy confuso quizás, veamos a qué me refiero con esto.\nComo vimos en nuestro ejemplo sobre la funcionalidad de blogs en Gherkin, podemos decir que al final del día estamos describiendo el comportamiento del usuario en ciertos escenarios, es decir, que cada uno de esos ejemplos sería un posible camino o situación experimentada por un usuario, teniendo entonces estrecha relación con el “comportamiento” mencionado por BDD (Desarrollo Guiado por Comportamiento). Pero ¿Cómo conectan los desarrolladores ese comportamiento descrito en Gherkin con tests que les ayuden a probar el sistema?\nCon Cucumber!\nVeamos un ejemplo con pseudocódigo para que se hagan una idea:\nCucumber aplicado a Gherkin Gracias a Cucumber todos los escenarios que redactamos en nuestro Gherkin ahora serán plantillas para disparar tests automatizados, convirtiendo cada oración de nuestro escenario en algo llamado “Step” o paso y asignandole a este paso se una secuencia de acciones/funciones llamadas “Sub Steps” o sub pasos que por detrás ejecutan código.\nAhora los desarrolladores podrán convertir los escenarios de Gherkin en disparadores de tests que corroboren que cada oración (Step) se cumpla, es decir, cuando se corra el test asociado al escenario “Pepe publica en el blog de un usuario” y se ejecute la oración o step “Dado que estoy logueado como Pepe” se esperá que el script corra un cierto código haciendo uso del sistema que implique loguear exitosamente a un usuario administrador, sí el script falla, el step falla y la condición no se cumple, haciendo así que falle el escenario y por consecuencia, falla el test.\nEn el caso de que todos los Steps (Dado, Cuando, Entonces) se ejecuten exitosamente, entonces el desarrollador habría logrado cumplir con el requerimiento expresado en dicho escenario.\nUniendo Gherkin + BDD + Cucumber # Flujo BDD Entendido entonces todo lo anterior, comprendemos que el flujo de desarrollo en un paradigma de BDD sería el que se enseña en la imagen.\n1: Se describe el comportamiento: Etapa en donde se realizaría la reunión de los tres amigos para discutir la funcionalidad del sistema ejemplificando con escenarios que resulten en la redacción de un documento redactado en Gherkin. (Tarea llevada a cabo por el PO, desarrolladores y testers) 2: Se escriben las definiciones de los Steps: es decir el contenido de scripts que va a asegurar que nuestro sistema esté haciendo lo que debería hacer teniendo en cuenta el comportamiento del usuario (Tarea llevada a cabo por desarrolladores) 3: Estos tests automatizados son corridos por los desarrolladores y van a fallar porque todavía no se escribió el código que logre que estas pruebas pasen. 4: Los desarrolladores escriben el código hasta lograr crear la nueva funcionalidad que cumple con los requisitos expresados en Gherkin. 5: Se corren los tests nuevamente y ahora los tests que fallaban al comienzo se ejecutan exitosamente al haberse logrado la funcionalidad deseada. ¿En que nos ayuda este paradigma o modelo?\nDependiendo de si empleabas algo como TDD o no, podías guiar tu desarrollo a partir de pruebas, pero la realidad es que aunque guíes tu desarrollo a partir de pruebas, no podes estar seguro de estar creando el sistema correcto, ya que tus pruebas solo están verificando que tu código funcione acorde a lo que vos entendiste de los requerimientos. A partir de emplear BDD, tus pruebas tienen un sentido y es conseguir que el usuario logre realizar ciertos steps o pasos y logre ciertos resultados en consecuencia, centrando el desarrollo en el usuario.\nPero todo lo que aprendemos en la teoría, luego puede cambiar en la práctica…\n¡Cambio de paradigma! # Si llegaste hasta acá y no te estás preguntando ¿Cuando va a hablar de los frameworks de Selenium con Gherkin y Cucumber BDD, etc? Vas por el camino correcto, de lo contrario puede que seas parte del paradigma actual, déjame explicarme.\nBDD no se trata de automatizar nada luego de la construcción de un sistema, todo lo contrario, se trata de automatizar las pruebas ANTES de la construcción del mismo.\nHasta este punto del artículo no hemos mencionado ninguna inferencia del tester en cuanto a programación o automatización…\n¿Se hacen pruebas automatizadas? Si\n¿Se busca verificar el correcto funcionamiento del sistema en cuanto a los requerimientos expresados en Gherkin? Por supuesto!\nPero son todas tareas que lleva adelante el desarrollador para verificar que el código que va escribiendo está cumpliendo con las condiciones expresadas en la definición del Gherkin creado por el equipo. No hay testers involucrados en la escritura de scripts hasta ese entonces, es una guía que ayuda al desarrollador a saber si está llevando adelante la correcta implementación del sistema que debe de crear.\nEntonces ¿Por qué hoy en día vemos tanta cantidad de videos que hacen referencia a Gherkin + Cucumber + BDD en Testing? Por el cambio de paradigma…\nLos testers nos apropiamos de estas palabras que pueden sonar “cool” para darle un uso distinto a algo que como vimos, ya tenía su uso. ¿Está mal? No, cualquiera puede usar las herramientas de la forma que desee, pero al menos entendamos el origen de todo este lío para saber la realidad detrás de todo esto.\n¿Recuerdan a Aslak? ¿El creador de Cucumber? Él más que nadie quiso vincular su producto con Gherkin para que los equipos de desarrollo adopten su framework para guiar las pruebas en BDD. En el episodio numero 55 del podcast Semaphore Uncut hace mención a este cambio:\nBDD y TDD no se trata de probar el código existente, se trata de diseñar un código que aún no se ha escrito. Eso es realmente difícil de entender para mucha gente, especialmente para no desarrolladores, porque tenés que ser programador para entender estos conceptos\nSi bien puede sonar fuerte, es verdad que entender cómo funciona algo como BDD y TDD es difícil para las personas que no programan, al no terminar de poder experimentar los conceptos en la práctica, pero no quedó allí, también mencionó:\nLa gente que lo adoptó en aquel entonces, eran testers. Gente que tradicionalmente había estado haciendo Testing manual ahora estaba adoptando Cucumber como una forma de automatizar sus tests. Y allí fue cuando comenzamos a ver el primer cambio de paradigma, ya que como dije antes TDD y BDD no se trata de Testing. Y al mismo tiempo, la gente empezó a usar Cucumber con herramientas de automatización de navegadores como Selenium webdriver.\nPodemos entender la frustración de Aslak viendo como un producto creado con el propósito de ser empleado en BDD se desvirtuó completamente, y por si no queda claro a qué se refiere Aslak, allí vamos!\nLa realidad de BDD en el Testing # Es conceptualmente imposible aplicar BDD en Testing, al menos de la forma en la que se lo implementa, si “creamos las pruebas que guían el desarrollo” luego de haber desarrollado ya no estaríamos guiando el desarrollo, estaríamos simplemente probando.\nVolviendo al flujo de BDD tendríamos algo como esto:\nVersión de BDD en Testing 1: La aplicación es construida por los desarrolladores bajo alguna metodología. 2: El tester describe el comportamiento de la aplicación basándose en el comportamiento ya existente o en los requisitos de los cuales se basó el desarrollador. 3: El tester programa los steps de las definiciones de Gherkin para probar el código ya existente a través de la utilización de la herramienta Cucumber. 4: El tester ejecuta los escenarios programados previamente y los tests pasan. Esto no es lo único que se altera…\nLa realidad de Gherkin en Testing # No más reuniones de “The Three Amigos” Así como gracias a Gherkin planteábamos la reunión de los tres amigos, consiguiendo que todos estemos de acuerdo en los requerimientos de las funcionalidades, bueno, eso ya no es así, el desarrollo ya fue llevado a cabo y si bien podemos redactar los requerimientos en Gherkin para luego utilizarlo como esqueleto de nuestras pruebas automatizadas ¿Qué sentido tiene si no va a ayudar a un desarrollo de mejor calidad en base a una colaboración temprana de las 3 partes (PO, Dev, Tester)?\nLamentablemente no nos ahorraremos entonces el mal gusto cuando nos damos cuenta que el sistema no fue diseñado en base a los requerimientos adecuadamente, recién puede que nos demos cuenta cuando estemos escribiendo la documentación en Gherkin por nuestra cuenta que la implementación resultó en un producto distinto a lo que planteaban los requerimientos.\nPodrías pensar que al menos usando Gherkin las pruebas quedan redactadas de forma amigable para el cliente, logrando que el mismo entienda lo que se está probando… ¿Estamos seguros?\nLuego del cambio de paradigma, nuestros escenarios de Gherkin dejaron de verse así:\nGherkin antes del cambio de paradigma Para verse algo parecido a esto:\nGherkin luego del cambio de paradigma Gherkin luego del cambio de paradigma ¿Qué podemos notar?\nEspanglish, y sí, no lo hice a propósito, es con lo que se van a encontrar cuando vean scripts en Cucumber y no, no hace falta que estén escritos en inglés, pero lo están, incluso cuando Cucumber soporta muchísimos idiomas, entre ellos el español. Se hace énfasis en la UI (Interfaz de Usuario) en lugar de al comportamiento del usuario como se hacía en el primer ejemplo. Se hace uso de tecnicismos al estar asociado a eventos que van a ocurrir dentro de una interfaz y qué están relacionados estrechamente al cómo y no al qué. Se extiende el tamaño del escenario, al querer explicar todo lo que hace nuestra prueba, cómo si ese fuese el propósito de Gherkin, construyendo algo similar a un caso de prueba. Se peca de sobrescribir cada pequeño paso que se realiza, pudiendo este ser parte de un sub paso. La cantidad de repetición aumenta, más oraciones van a ser reescritas y con ello la dificultad de mantenimiento a la hora de modificar un caso debido a un cambio en la implementación del sistema. Entendemos entonces que no es sólo un tema de preferencias y de utilizar las herramientas para lo que fueron creadas, sino que realmente trae puntos negativos a algo tan sensible como la creación de un proceso de pruebas automatizadas. ¿Por qué no cambiamos nuevamente? # De por sí es complicado entender cómo llegamos acá en un principio, habría que analizar cuáles son las causas por las que estamos acá en un inicio y en mi opinión son las siguientes:\nReportería: La reportería juega un gran rol en Testing, demostrar qué hacemos en nuestro trabajo es un punto de dolor que como testers tenemos que solventar, para así justificar el tiempo invertido en las tareas que realizamos. Cucumber nos ayuda a generar reportería, por si solo o complementado con otras herramientas, lo cual ayuda a mostrar tanto el trabajo cómo un análisis de forma natural. Desconocimiento: Nadie nace sabiendo, y nadie aplica “Gherkin + Cucumber + BDD” habiendo investigado su origen, por lo tanto atribuyo parte del problema a la falta de investigación de los equipos antes de sumergirse en una solución que puede no ser lo que creían. La mayoría de los testers aprendemos de alguien más, y si ese alguien más tampoco conoce la imagen completa, estaremos destinados a seguir su camino. Darnos a entender: En Testing sucede algo parecido a lo que sucede en desarrollo, cuando un tester se va o cuando un nuevo tester ingresa, queremos que el ingresante o reemplazante sepa con más claridad que es lo que están haciendo nuestras pruebas, pero no por eso el desarrollador pone un comentario por cada línea y no por eso debería el tester explicar cada clic que realiza sobre una UI en un Gherkin.\nPara concluir… # Existen formas en las cuáles podemos utilizar Gherkin y Cucumber para crear un framework de Testing automatizado que tenga sentido, aunque esto podría ser abordado en otro artículo dependiendo de qué tan bien recibido sea el actual.\nMe encantaría que dejen un comentario con su mirada, crítica o consejo acerca del tema y juntos sigamos construyendo una mejor comunidad de Testing cada día.\nUn abrazo grande, Nacho.\n","date":"16 de enero de 2024","externalUrl":null,"permalink":"/posts/gherkin_bdd_y_cucumber_una_historia_mal_contada_en_testing/","section":"Publicaciones","summary":"Poco después de haber dado mis primeros pasos en el mundo de las pruebas automatizadas escuché nombrar estos tres términos en conjunto por primera vez, mi acercamiento inicial me llevó a la misma","title":"Gherkin, BDD y Cucumber, una historia mal contada en Testing","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" Previous Next \u0026nbsp; \u0026nbsp; / [pdf] View the PDF file here. Abrir Currículum Vitae en una pestaña\n","externalUrl":null,"permalink":"/cv/","section":"Ignacio Sambrailo","summary":"","title":"Currículum Vitae","type":"page"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" Me llamo \u0026lt;tester_name\u0026gt;, tengo \u0026lt;tester_age\u0026gt; años y pruebo software.\nComencé mis estudios cursando poco más de un año de Ingeniería en Sistemas de Información, para luego abandonarlo convirtiendome en Técnico Sonidista. Retomé mi interés por sistemas gracias a un curso de Google acerca de User Experience.\nMi forma de pensar el Testing tuvo varias etapas y descubrimientos, el comienzo de mi carrera profesional fue en NEORIS, donde ocupé primeramente el puesto de Tester Trainee. Rápidamente fuí sintiendo mucha más curiosidad por el rubro, lo cual me llevó a buscar aprender de mis colegas y a querer compartir mi mirada.\nSoy una persona apasionada, me interesa realizar mis tareas con dedicación, mi peor enemigo es el aburrimiento. Si voy a dedicarle tiempo a algo, es preferible que lo haga lo mejor que pueda, de otra forma no tiene sentido, esa es mi filosofía.\nSiempre me gustó escribir, lo cual no significa que escriba muy seguido, pero para cuando sí lo hago, creé esta web. Acá vas a encontrar reflexiones, divagues e ideas que pueden ser de utilidad, me gusta compartir mis conocimientos y creencias, así como también estudiar y leer acerca de lo que escribo.\nSi querés hablar conmigo sobre Testing, trabajo o algo que creas que pueda interesarme, mis redes están disponibles en esta web, no dudes en contactarme.\n\u0026lt;abrazo_greeting\u0026gt;\n","externalUrl":null,"permalink":"/about/","section":"Ignacio Sambrailo","summary":"","title":"Sobre mi","type":"page"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]